<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>html/Listing_of_common.vhd</TITLE>
<META NAME="generator" CONTENT="HTML::TextToHTML v2.46">
<LINK REL="stylesheet" TYPE="text/css" HREF="lecture.css">
</HEAD>
<BODY>
<P><table class="ttop"><th class="tpre"><a href="12_Listing_of_baudgen.vhd.html">Previous Lesson</a></th><th class="ttop"><a href="toc.html">Table of Content</a></th><th class="tnxt"><a href="14_Listing_of_cpu_core.vhd.html">Next Lesson</a></th></table>
<hr>

<H1><A NAME="section_1">13 LISTING OF common.vhd</A></H1>

<pre class="vhdl">

  1	-------------------------------------------------------------------------------
  2	-- 
  3	-- Copyright (C) 2009, 2010 Dr. Juergen Sauermann
  4	-- 
  5	--  This code is free software: you can redistribute it and/or modify
  6	--  it under the terms of the GNU General Public License as published by
  7	--  the Free Software Foundation, either version 3 of the License, or
  8	--  (at your option) any later version.
  9	--
 10	--  This code is distributed in the hope that it will be useful,
 11	--  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12	--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 13	--  GNU General Public License for more details.
 14	--
 15	--  You should have received a copy of the GNU General Public License
 16	--  along with this code (see the file named COPYING).
 17	--  If not, see http://www.gnu.org/licenses/.
 18	--
 19	-------------------------------------------------------------------------------
 20	-------------------------------------------------------------------------------
 21	--  
 22	-- Module Name:    common
 23	-- Create Date:    13:51:24 11/07/2009 
 24	-- Description:    constants shared by different modules.
 25	--
 26	-------------------------------------------------------------------------------
 27	--
 28	library IEEE;
 29	use IEEE.STD_LOGIC_1164.all;
 30	
 31	package common is
 32	
 33	    -----------------------------------------------------------------------
 34	
 35	    -- ALU operations
 36	    --
 37	    constant ALU_ADC    : std_logic_vector(4 downto 0) := "00000";
 38	    constant ALU_ADD    : std_logic_vector(4 downto 0) := "00001";
 39	    constant ALU_ADIW   : std_logic_vector(4 downto 0) := "00010";
 40	    constant ALU_AND    : std_logic_vector(4 downto 0) := "00011";
 41	    constant ALU_ASR    : std_logic_vector(4 downto 0) := "00100";
 42	    constant ALU_BLD    : std_logic_vector(4 downto 0) := "00101"; 
 43	    constant ALU_BIT_CS : std_logic_vector(4 downto 0) := "00110";
 44	    constant ALU_COM    : std_logic_vector(4 downto 0) := "00111";
 45	    constant ALU_DEC    : std_logic_vector(4 downto 0) := "01000";
 46	    constant ALU_EOR    : std_logic_vector(4 downto 0) := "01001";
 47	    constant ALU_MV_16  : std_logic_vector(4 downto 0) := "01010";
 48	    constant ALU_INC    : std_logic_vector(4 downto 0) := "01011";
 49	    constant ALU_INTR   : std_logic_vector(4 downto 0) := "01100";
 50	    constant ALU_LSR    : std_logic_vector(4 downto 0) := "01101";  
 51	    constant ALU_D_MV_Q : std_logic_vector(4 downto 0) := "01110";  
 52	    constant ALU_R_MV_Q : std_logic_vector(4 downto 0) := "01111";  
 53	    constant ALU_MULT   : std_logic_vector(4 downto 0) := "10000";
 54	    constant ALU_NEG    : std_logic_vector(4 downto 0) := "10001";
 55	    constant ALU_OR     : std_logic_vector(4 downto 0) := "10010";  
 56	    constant ALU_PC_1   : std_logic_vector(4 downto 0) := "10011";  
 57	    constant ALU_PC_2   : std_logic_vector(4 downto 0) := "10100";  
 58	    constant ALU_ROR    : std_logic_vector(4 downto 0) := "10101";
 59	    constant ALU_SBC    : std_logic_vector(4 downto 0) := "10110";
 60	    constant ALU_SBIW   : std_logic_vector(4 downto 0) := "10111";
 61	    constant ALU_SREG   : std_logic_vector(4 downto 0) := "11000";
 62	    constant ALU_SUB    : std_logic_vector(4 downto 0) := "11001";
 63	    constant ALU_SWAP   : std_logic_vector(4 downto 0) := "11010";
 64	
 65	    -----------------------------------------------------------------------
 66	    --
 67	    -- PC manipulations
 68	    --
 69	    constant PC_NEXT    : std_logic_vector(2 downto 0) := "000";    -- PC += 1
 70	    constant PC_BCC     : std_logic_vector(2 downto 0) := "001";    -- PC ?= IMM
 71	    constant PC_LD_I    : std_logic_vector(2 downto 0) := "010";    -- PC = IMM
 72	    constant PC_LD_Z    : std_logic_vector(2 downto 0) := "011";    -- PC = Z
 73	    constant PC_LD_S    : std_logic_vector(2 downto 0) := "100";    -- PC = (SP)
 74	    constant PC_SKIP_Z  : std_logic_vector(2 downto 0) := "101";    -- SKIP if Z
 75	    constant PC_SKIP_T  : std_logic_vector(2 downto 0) := "110";    -- SKIP if T
 76	 
 77	    -----------------------------------------------------------------------
 78	    --
 79	    -- Addressing modes. An address mode consists of two sub-fields,
 80	    -- which are the source of the address and an offset from the source.
 81	    -- Bit 3 indicates if the address will be modified.
 82	
 83	    -- address source
 84	    constant AS_SP  : std_logic_vector(2 downto 0) := "000";     -- SP
 85	    constant AS_Z   : std_logic_vector(2 downto 0) := "001";     -- Z
 86	    constant AS_Y   : std_logic_vector(2 downto 0) := "010";     -- Y
 87	    constant AS_X   : std_logic_vector(2 downto 0) := "011";     -- X
 88	    constant AS_IMM : std_logic_vector(2 downto 0) := "100";     -- IMM
 89	
 90	    -- address offset
 91	    constant AO_0   : std_logic_vector(5 downto 3) := "000";     -- as is
 92	    constant AO_Q   : std_logic_vector(5 downto 3) := "010";     -- +q
 93	    constant AO_i   : std_logic_vector(5 downto 3) := "001";     -- +1
 94	    constant AO_ii  : std_logic_vector(5 downto 3) := "011";     -- +2
 95	    constant AO_d   : std_logic_vector(5 downto 3) := "101";     -- -1
 96	    constant AO_dd  : std_logic_vector(5 downto 3) := "111";     -- -2
 97	    --                                                   |
 98	    --                                                +--+
 99	    -- address updated ?                              |
100	    --                                                v
101	    constant AM_WX : std_logic_vector(3 downto 0) := '1' & AS_X;  -- X ++ or --
102	    constant AM_WY : std_logic_vector(3 downto 0) := '1' & AS_Y;  -- Y ++ or --
103	    constant AM_WZ : std_logic_vector(3 downto 0) := '1' & AS_Z;  -- Z ++ or --
104	    constant AM_WS : std_logic_vector(3 downto 0) := '1' & AS_SP;  -- SP ++/--
105	
106	    -- address modes used
107	    --
108	    constant AMOD_ABS : std_logic_vector(5 downto 0) := AO_0  & AS_IMM;  -- IMM
109	    constant AMOD_X   : std_logic_vector(5 downto 0) := AO_0  & AS_X;  -- (X)
110	    constant AMOD_Xq  : std_logic_vector(5 downto 0) := AO_Q  & AS_X;  -- (X+q)
111	    constant AMOD_Xi  : std_logic_vector(5 downto 0) := AO_i  & AS_X;  -- (X++)
112	    constant AMOD_dX  : std_logic_vector(5 downto 0) := AO_d  & AS_X;  -- (--X)
113	    constant AMOD_Y   : std_logic_vector(5 downto 0) := AO_0  & AS_Y;  -- (Y)
114	    constant AMOD_Yq  : std_logic_vector(5 downto 0) := AO_Q  & AS_Y;  -- (Y+q)
115	    constant AMOD_Yi  : std_logic_vector(5 downto 0) := AO_i  & AS_Y;  -- (Y++)
116	    constant AMOD_dY  : std_logic_vector(5 downto 0) := AO_d  & AS_Y;  -- (--Y)
117	    constant AMOD_Z   : std_logic_vector(5 downto 0) := AO_0  & AS_Z;  -- (Z)
118	    constant AMOD_Zq  : std_logic_vector(5 downto 0) := AO_Q  & AS_Z;  -- (Z+q)
119	    constant AMOD_Zi  : std_logic_vector(5 downto 0) := AO_i  & AS_Z;  -- (Z++)
120	    constant AMOD_dZ  : std_logic_vector(5 downto 0) := AO_d  & AS_Z;  -- (--Z)
121	    constant AMOD_SPi : std_logic_vector(5 downto 0) := AO_i  & AS_SP; -- (SP++)
122	    constant AMOD_SPii: std_logic_vector(5 downto 0) := AO_ii & AS_SP; -- (SP++)
123	    constant AMOD_dSP : std_logic_vector(5 downto 0) := AO_d  & AS_SP; -- (--SP)
124	    constant AMOD_ddSP: std_logic_vector(5 downto 0) := AO_dd & AS_SP; -- (--SP)
125	    
126	    -----------------------------------------------------------------------
127	 
128	    -- Stack pointer manipulations.
129	    --
130	    constant SP_NOP : std_logic_vector(2 downto 0) := "000";
131	    constant SP_ADD1: std_logic_vector(2 downto 0) := "001";
132	    constant SP_ADD2: std_logic_vector(2 downto 0) := "010";
133	    constant SP_SUB1: std_logic_vector(2 downto 0) := "011";
134	    constant SP_SUB2: std_logic_vector(2 downto 0) := "100";
135	    
136	    -----------------------------------------------------------------------
137	    --
138	    -- ALU multiplexers.
139	    --
140	    constant RS_REG : std_logic_vector(1 downto 0) := "00";
141	    constant RS_IMM : std_logic_vector(1 downto 0) := "01";
142	    constant RS_DIN : std_logic_vector(1 downto 0) := "10";
143	
144	    -----------------------------------------------------------------------
145	    --
146	    -- Multiplier variants. F means FMULT (as opposed to MULT).
147	    -- S and U means signed vs. unsigned operands.
148	    --
149	    constant MULT_UU  : std_logic_vector(2 downto 0) := "000";
150	    constant MULT_SU  : std_logic_vector(2 downto 0) := "010";
151	    constant MULT_SS  : std_logic_vector(2 downto 0) := "011";
152	    constant MULT_FUU : std_logic_vector(2 downto 0) := "100";
153	    constant MULT_FSU : std_logic_vector(2 downto 0) := "110";
154	    constant MULT_FSS : std_logic_vector(2 downto 0) := "111";
155	
156	    -----------------------------------------------------------------------
157	
158	end common;
159	
<pre class="filename">
src/common.vhd
</pre></pre>
<P>

<P><hr><BR>
<table class="ttop"><th class="tpre"><a href="12_Listing_of_baudgen.vhd.html">Previous Lesson</a></th><th class="ttop"><a href="toc.html">Table of Content</a></th><th class="tnxt"><a href="14_Listing_of_cpu_core.vhd.html">Next Lesson</a></th></table>
</BODY>
</HTML>
